# Import necessary tools 
from picamera.array import PiRGBArray
from picamera import PiCamera
import time
import cv2
import numpy as np
import sys
import math
import smbus
import smbus2
import board
import adafruit_character_lcd.character_lcd_rgb_i2c as character_lcd

# LCD and I2C info
lcd_columns = 16
lcd_rows = 2
i2c = board.I2C()
lcd = character_lcd.Character_LCD_RGB_I2C(i2c, lcd_columns, lcd_rows)
lcd.clear()
abus = smbus.SMBus(1)
address = 0x2a
slave_address = 20

#Declare variables
output= 0
info = 0

# Function to write info to the arduino and LCD, returns error if there is a communication error
def writeNumber(comOutput):
    try:
        abus.write_byte(address,comOutput)
    except:
        print('io error')
    
    try:
        info = ""
        for i in range(0,3):
            info += chr(abus.read_byte(address));
        print(info)
        print('\n')
    except:
        print('io error')
    
    target = ''
    if ( comOutput == 0 ):
        target = '00'
    elif ( comOutput == 1 ):
        target = '090'
    elif ( comOutput == 2 ):
        target = '180'
    elif ( comOutput == 3 ):
        target = '270'
    lcd.message = 'Current: ' + str(info) + '\nTarget: ' + str(target) 
    
    return -1

    

# Update setpoint on LCD
def readLCD(setpoint):
    
    setPrint = 'Setpoint: ' + str(setpoint)
    lcd.message = setPrint 


# Read in calibration matrix 
with open ('camera_cal.npy', 'rb') as f:
    camera_matrix = np.load(f)
    camera_distortion = np.load(f)
   
# Define marker size and import appropriate arcuo dictionary   
aruco_dict = aruco.Dictionary_get(aruco.DICT_4X4_50)
marker_size =50

# Begin Video
cap = cv2.VideoCapture(0)

# Set camera specs
camera_width = 640
camera_height = 480
camera_frame_rate = 40

while(True):

# Adding user input for distance
    # var = input('Enter a distance 1 - 10 feet: ")
    # var = int(var)
    # if not var:
    # continue
    # writeNumber(var)
    # print("RPI: Hi Arduino, I sent you ", var, " feet")
   
    ret, frame = cap.read()
    
    # Convert frame to greyscale 
    grey = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    
    # Check frame for aruco markers 
    corners, ids, rejectedImgPoints = aruco.detectMarkers(grey, aruco_dict, camera_matrix, camera_distortion)
  
    # Enter this if an ID is detected in the frame 
    if ids is not None:
    
            # Draw overlay on any detected markers 
            aruco.drawDetectedMarkers(frame, corners)
            rvec_list_all, tvec_list_all, _objPoints = aruco.estimatePoseSingleMarkers(corners, marker_size, camera_matrix, camera_distortion)
            rvec= rvec_list_all[0][0]
            tvec = tvec_list_all[0][0]
            aruco.drawAxis(frame, camera_matrix, camera_distortion, rvec, tvec, 100)
            
            # Perform calculations to determine X, Y, and angle values 
            rvec_flipped = rvec * 1
            tvec_flipped = tvec * 1
            rotation_matrix, jacobian = cv2.Rodrigues(rvec_flipped)
            realworld_tvec = np.dot(rotation_matrix, tvec_flipped)
            
            pitch, roll, yaw = rotationMatrixToEulerAngles(rotation_matrix)
            
            # Display calculated values on the frame 
            tvec_str = "x=%4.0f y%4.0f angle=%4.0f"%(realworld_tvec[0], realworld_tvec[1], math.degrees(yaw))
            
            # Determine which quadrent the aruco marker is located in 
            if (realworld_tvec[0] < 1 and realworld_tvec[1] < 1):
                output = 0
                print(output)
                
            elif (realworld_tvec[0] < 1 and realworld_tvec[1] > 1):
                output = 1
                print(output)
                
            elif (realworld_tvec[0] > 1 and realworld_tvec[1] < 1):
                output = 2
                print(output)
            elif (realworld_tvec[0] > 1 and realworld_tvec[1] > 1):
                output = 3
                print(output)
                
            # Write the ouput to the arduino and display the information on the display 
            writeNumber(output)
            cv2.putText(frame, tvec_str, (20,460), cv2.FONT_HERSHEY_PLAIN, 2, (0, 0, 255), 2, cv2.LINE_AA)
                
    cv2.imshow("frame", frame)

    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        break
  
cap.release()
cv.destroyAllWindows()
