from cv2 import aruco
import cv2
import numpy as np
import math
import smbus
import smbus2
import board
import time
from picamera.array import PiRGBArray
from picamera import PiCamera
import sys
import math
import threading
import pickle
import os


FOV_X = 53.50
FOV_Y = 41.41

angle = 0.0 
dist = 0.0
detect = 0.0
marker_size = 32

address = 0x2a
slave_address = 0x20
bus = smbus.SMBus(1)
time.sleep(1)
i2c = board.I2C()

data = ''

class CameraBufferCleanerThread(threading.Thread):
    def __init__(self, camera, name='camera-buffer-cleaner-thread'):
        self.camera = camera
        self.last_frame = None
        super(CameraBufferCleanerThread, self).__init__(name=name)
        self.start()

    def run(self):
        while True:
            ret, self.last_frame = self.camera.read()
            

with open ('camera_cal1.npy', 'rb') as f:
    camera_matrix = np.load(f)
    camera_distortion = np.load(f)
 
 
 # Start the camera and configure settings to deal with frame rate and motion blur
camera = cv2.VideoCapture(0)
#camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1000)
#camera.set(cv2.CAP_PROP_FRAME_WIDTH, 1000)
camera.set(cv2.CAP_PROP_BUFFERSIZE, 2);
camera.set(cv2.CAP_PROP_FPS, 20);
camera.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.75);
camera.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.25);
camera.set(cv2.CAP_PROP_EXPOSURE, 30);


# Measure and adjust marker size as accordingly; this is important for accurately measuring distance
markerSize = 5.00 # in cm, 5.39 for demo1 marker, 5.08 for the one we printed out, IMPORTANT: CHANGE ON DAY OF DEMO # 4.5 cm
# Start the cleaning thread
cam_cleaner = CameraBufferCleanerThread(camera)


aruco_dict = aruco.Dictionary_get(aruco.DICT_4X4_50)


def writeNumber(comDetect, comAngle, comDist):
    global data
    if comDetect == True:
   
        try:
            if data != '234':
                data = ''
                for i in range(0,3):
                    data += chr(abus.read_byte(address))
                print(data)
            if data == '234':
                abus.write_bus(address, comDist)
                data = ''
            else:
                abus.write_byte(address, comAngle)
        except:
            None
    else:
        print('io error')

    return -1
    
#def readNumber():
#    number1 = bus.read_byte(address)
#    number2 = bus.read_byte(address)
#    number3 = bus.read_byte(address)
#    return number1, number2, number3



while True:
    if cam_cleaner.last_frame is not None:

      grey = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    
      h, w, c = grey.shape
      size = (w, h)
      center = (w/2, h/2)

      h, w = img.shape[:2]
    # check if markers were found
        if ids is not None:
        detect = 1
            # loop through if there are multiple markers

            for x in range(len(ids)):
                # find the mix right side and min left side
                min_x = 100000
                max_x = 0
                for i in range(len(corners[0][0])):
                    if corners[x][0][i][0] < min_x:
                        min_x = corners[0][0][i][0]
                    if corners[x][0][i][0] > max_x:
                        max_x = corners[0][0][i][0]

                # find the center of the aruco marker
                centerObject = (min_x + max_x) / 2
                # find pix of marker
                pix = max_x - min_x

                # calculate the distance
                distance = (marker_size) / (math.tan((math.radians(FOV_X) * pix)/size[0]))

                # return the angle
                return distance
                # if the center of the aruco marker is less than the center of the image
                # then the aruco marker is to the left of the center of the image making the angle negative
                if centerObject < center[0]:
                    angle = -1 * (FOV_X / 2) * ( (abs(centerObject - center[0])) / (abs(center[0] - size[0])) )
                else:
                    angle = (FOV_X / 2) * ( (abs(centerObject - center[0])) / (abs(center[0] - size[0])) )

                # return the angle
                return angle
                

               
        else:
            return None
            detect = 0
                
     def writeNumber(detect, angle, distance):       
        
    
    cv2.imshow("frame", frame)
    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        break
  
cap.release()
cv.destroyAllWindows()
