from cv2 import aruco
import cv2
import numpy as np
import math
import smbus
import smbus2
import board
import time

FOV_X = 53.50
FOV_Y = 41.41

angle = 0.0 
dist = 0.0
detect = 0.0
marker_size = 32

address = 0x2a
slave_address = 0x20
bus = smbus.SMBus(1)
time.sleep(1)
i2c = board.I2C()

data = ''


with open ('camera_cal1.npy', 'rb') as f:
    camera_matrix = np.load(f)
    camera_distortion = np.load(f)
    
aruco_dict = aruco.Dictionary_get(aruco.DICT_4X4_50)

cap = cv2.VideoCapture(0)

camera_width = 1280
camera_height = 960
camera_frame_rate = 20

def writeNumber(comDetect, comAngle, comDist):
    global data
    if comDetect == True:
   
        try:
            if data != '234':
                data = ''
                for i in range(0,3):
                    data += chr(abus.read_byte(address))
                print(data)
            if data == '234':
                abus.write_bus(address, comDist)
                data = ''
            else:
                abus.write_byte(address, comAngle)
        except:
            None
    else:
        print('io error')

    return -1
    
#def readNumber():
#    number1 = bus.read_byte(address)
#    number2 = bus.read_byte(address)
#    number3 = bus.read_byte(address)
#    return number1, number2, number3


#until q is pressed, images will continously be taken, converted to greyscale, and if an ID is detected the math preformed and displayed to calculate the angle 
while True:
    
    ret, frame = cap.read()

    grey = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    
    h, w, c = grey.shape
    size = (w, h)
    center = (w/2, h/2)

    h, w = img.shape[:2]
    # check if markers were found
        if ids is not None:
            # loop through if there are multiple markers

            for x in range(len(ids)):
                # find the mix right side and min left side
                min_x = 100000
                max_x = 0
                for i in range(len(corners[0][0])):
                    if corners[x][0][i][0] < min_x:
                        min_x = corners[0][0][i][0]
                    if corners[x][0][i][0] > max_x:
                        max_x = corners[0][0][i][0]

                # find the center of the aruco marker
                centerObject = (min_x + max_x) / 2

                # if the center of the aruco marker is less than the center of the image
                # then the aruco marker is to the left of the center of the image making the angle negative
                if centerObject < center[0]:
                    angle = -1 * (FOV_X / 2) * ( (abs(centerObject - center[0])) / (abs(center[0] - size[0])) )
                else:
                    angle = (FOV_X / 2) * ( (abs(centerObject - center[0])) / (abs(center[0] - size[0])) )

                # return the angle
                return angle
                
          if ids is not None:
            # loop through if there are multiple markers
            for x in range(len(ids)):
                # find the mix right side and min left side
                min_x = 100000
                max_x = 0
                for i in range(len(corners[0][0])):
                    if corners[x][0][i][0] < min_x:
                        min_x = corners[0][0][i][0]
                    if corners[x][0][i][0] > max_x:
                        max_x = corners[0][0][i][0]

                # find pix of marker
                pix = max_x - min_x

                # calculate the distance
                distance = (self.marker_size) / (math.tan((math.radians(self.FOV_X) * pix)/size[0]))

                # return the angle
                return distance
        else:
            return None
                
     def writeNumber(comDetect, angle, distance):       
        
    
    cv2.imshow("frame", frame)
    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        break
  
cap.release()
cv.destroyAllWindows()

        

        
